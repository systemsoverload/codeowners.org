<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Tree-sitter Custom Grammar</title>
  <style>
    .playground-container {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      padding: 1rem;
    }

    .editor-container {
      display: flex;
      gap: 1rem;
    }

    #source-code, #tree-output {
      width: 100%;
      height: 400px;
      font-family: monospace;
      padding: 0.5rem;
    }

    #tree-output {
      white-space: pre;
      overflow: auto;
      background: #f5f5f5;
    }
  </style>
</head>
<body>
  Testing
  <div class="playground-container">
    <div class="editor-container">
      <textarea id="source-code">// Enter your code here</textarea>
      <pre id="tree-output"></pre>
    </div>
  </div>

  <script>
    let Parser;

    async function initializeParser() {
      // Load the WASM module for your custom grammar
      const wasmUrl = './tree-sitter.wasm';
      const wasmModule = await WebAssembly.instantiateStreaming(
        fetch(wasmUrl),
        {
          env: {
            memory: new WebAssembly.Memory({ initial: 2048, maximum: 2048 })
          }
        }
      );

      Parser = wasmModule.instance.exports;
      return Parser;
    }

    async function parseCode(sourceCode) {
      const inputPtr = Parser.malloc(sourceCode.length);
      const input = new Uint8Array(Parser.memory.buffer, inputPtr, sourceCode.length);

      // Copy input string to WASM memory
      for (let i = 0; i < sourceCode.length; i++) {
        input[i] = sourceCode.charCodeAt(i);
      }

      // Parse the input
      const treePtr = Parser.parse(inputPtr, sourceCode.length);

      // Get the resulting tree
      const tree = formatTree(treePtr);

      // Clean up
      Parser.free(inputPtr);
      return tree;
    }

    function formatTree(nodePtr, level = 0) {
      if (nodePtr === 0) return '';

      const type = Parser.node_type(nodePtr);
      const childCount = Parser.node_child_count(nodePtr);
      const startByte = Parser.node_start_byte(nodePtr);
      const endByte = Parser.node_end_byte(nodePtr);

      const indent = '  '.repeat(level);
      let result = `${indent}${type}`;

      if (childCount === 0) {
        const text = document.getElementById('source-code').value.substring(startByte, endByte);
        result += `: "${text}"`;
      }

      result += '\n';

      // Format children
      for (let i = 0; i < childCount; i++) {
        const childPtr = Parser.node_child(nodePtr, i);
        result += formatTree(childPtr, level + 1);
      }

      return result;
    }

    // Initialize playground
    async function initPlayground() {
      await initializeParser();
      const sourceCodeElement = document.getElementById('source-code');
      const treeOutput = document.getElementById('tree-output');

      // Update parse tree when source code changes
      sourceCodeElement.addEventListener('input', async () => {
        try {
          const sourceCode = sourceCodeElement.value;
          const formattedTree = await parseCode(sourceCode);
          treeOutput.textContent = formattedTree;
        } catch (error) {
          treeOutput.textContent = `Error: ${error.message}`;
        }
      });
    }

    initPlayground().catch(error => {
      document.getElementById('tree-output').textContent = `Initialization Error: ${error.message}`;
    });
  </script>
</body>
</html>
